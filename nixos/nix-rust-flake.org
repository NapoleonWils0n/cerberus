#+STARTUP: content
* nix rust flake
** resources

[[https://www.youtube.com/watch?v=Ss1IXtYnpsg]]

[[https://wiki.nixos.org/wiki/Rust]]

[[https://github.com/nix-community/naersk]]

[[https://github.com/oxalica/rust-overlay]]

[[https://rust-lang.org/]]

[[https://doc.rust-lang.org/book/]]

** create directory

#+begin_src sh
mkdir -p ~/nix/rust
#+end_src

#+begin_src sh
cd ~/nix/rust
#+end_src

** flake

create the flake.nix

#+begin_src nix
{
  description = "rust flake";

  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs?ref=nixos-unstable";
    naersk.url = "github:nix-community/naersk";
    rust-overlay = {
      url = "github:oxalica/rust-overlay";
      inputs.nixpkgs.follows = "nixpkgs";
    };
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, nixpkgs, naersk, rust-overlay, flake-utils }: 
    flake-utils.lib.eachDefaultSystem (system:
    let
      # system is already provided by eachDefaultSystem, so we don't define it here
      overlays = [ (import rust-overlay) ];
      pkgs = import nixpkgs { inherit system overlays; };

      rustToolchain = pkgs.rust-bin.stable.latest.default.override {
        extensions = [ "rust-src" "rust-analyzer" ];
        targets = [ "x86_64-unknown-linux-musl" "x86_64-pc-windows-gnu" ]; 
      };

      naerskLib = (naersk.lib.${system}.override {
        cargo = rustToolchain;
        rustc = rustToolchain;
      });
    in {
      devShells.default = pkgs.mkShell {
        # ADD MINGW TO THE SHELL FOR LINKING
        buildInputs = [ 
          rustToolchain 
          pkgs.pkgsCross.mingwW64.stdenv.cc 
        ];


        # Tell Cargo which linker to use for Windows
        # Add these lines to help the linker find pthreads
        shellHook = ''
          export RUST_SRC_PATH="${rustToolchain}/lib/rustlib/src/rust/library"
          export NIX_CROSS_LDFLAGS="-L${pkgs.pkgsCross.mingwW64.windows.pthreads}/lib"
          export NIX_CROSS_CFLAGS_COMPILE="-I${pkgs.pkgsCross.mingwW64.windows.pthreads}/include"
          export CARGO_TARGET_X86_64_PC_WINDOWS_GNU_LINKER="x86_64-w64-mingw32-gcc"
          export CARGO_TARGET_X86_64_PC_WINDOWS_GNU_RUSTFLAGS="-L ${pkgs.pkgsCross.mingwW64.windows.pthreads}/lib"
        '';
      };

      packages.default = naerskLib.buildPackage {
        src = ./.;
      };
    } 
  ); # This closes eachDefaultSystem
}    # This closes outputs
#+end_src

** git init

#+begin_src sh
git init .
#+end_src

#+begin_src sh
git add flake.nix
#+end_src

** nix develop

#+begin_src sh
nix develop
#+end_src

** cargo init

#+begin_src sh
cargo init
#+end_src

** git stage

#+begin_src sh
git add -A
#+end_src

** cargo run

#+begin_src sh
cargo run
#+end_src

** nix build

Final check to see if the flake can package the app correctly

#+begin_src sh
nix build
#+end_src

Nix will look at your packages.default output.

It will use the Naersk library that you specifically overridden with your rustToolchain.

It creates a folder called result in your current directory.

You can run your final compiled binary with ./result/bin/rust.

Why this is "Portable"

Because you used this specific naerskLib override , if you ever want to build this for Debian as we discussed, you would simply add the musl target to your rustToolchain definition in the flake.nix and Nix will handle the rest

** How to Organize Multiple Scripts

Instead of having just one main.rs, create a folder named bin inside your src folder.

Each .rs file you put in there becomes its own independent script/binary.

Your folder structure would look like this:

#+begin_example
.
├── Cargo.toml
├── flake.nix
└── src
    ├── main.rs       <-- Your "default" program
    └── bin           <-- Put your scripts here
        ├── video_convert.rs
        ├── audio_extract.rs
        └── thumbnail_gen.rs
#+end_example

How to Run Them

When you have multiple binaries, you just tell Cargo which one you want to run using the --bin flag:

#+begin_src sh
cargo run --bin video_convert
cargo run --bin audio_extract
#+end_src

How to Build Them for Debian (Static)

The same logic applies to your cross-compilation.

If you want to build your video_convert script for your Debian machine:

#+begin_src sh
cargo build --target x86_64-unknown-linux-musl --release --bin video_convert
#+end_src

** compile for debian

#+begin_src sh
cargo build --target x86_64-unknown-linux-musl
#+end_src

Where to find the file

After the build finishes, your static binary won't be in the usual target/debug/ folder. It will be located at:

#+begin_example
target/x86_64-unknown-linux-musl/debug/rust
#+end_example

This binary is statically linked. You can copy just that one file to a Debian machine, and it will run perfectly even if that machine doesn't have Nix, Rust, or even the same version of C libraries (glibc) installed.
