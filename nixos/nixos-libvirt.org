#+STARTUP: content hideblocks
* nixos libvirt
** configuration.nix
*** configuration.nix snippet

#+begin_src nix
# spice-vdagentd
services = { 
  spice-vdagentd.enable = true;      # Guest agent for SPICE (copy/paste, etc.)
}

# Libvirtd
virtualisation = {
   # New Libvirtd settings for Windows 11
    libvirtd = {
      enable = true;
      qemu = {
        package = pkgs.qemu_kvm;
        runAsRoot = true;
        swtpm.enable = true; # Required for Windows 11 TPM
      };
    };
    spiceUSBRedirection.enable = true;
};


# add user to Libvirtd group
users.users.djwilcox = {
    isNormalUser = true;
    extraGroups = [ "wheel" "networkmanager" "audio" "video" "oci" "libvirtd" ]; # Enable ‘sudo’ for the user.
};

# dconf
programs = {
  dconf.enable = true;
};
#+end_src

*** configuration.nix complete

#+begin_src nix
# Edit this configuration file to define what should be installed on
# your system. Help is available in the configuration.nix(5) man page, on
# https://search.nixos.org/options and in the NixOS manual (`nixos-help`).

{ config, lib, pkgs, ... }:

let
  # 1. Define your customized dwl package
  myCustomDwlPackage = (pkgs.dwl.override {
    configH = ./dwl/config.h;
  }).overrideAttrs (oldAttrs: {
    patches = (oldAttrs.patches or []) ++ [
      ./dwl/movestack.patch # Using the direct path for the patch
    ];
    # Add any necessary buildInputs if your config.h or patches require them
    # For a bar, you might need fcft for font rendering.
    buildInputs = oldAttrs.buildInputs or [] ++ [ pkgs.libdrm pkgs.fcft ];
  });

  # 2. Create a wrapper script that launches dwl with dwlb as the status bar
  dwlWithDwlbWrapper = pkgs.writeScriptBin "dwl-with-dwlb" ''
      #!/bin/sh
      # launch your customized dwl with its arguments
      exec ${lib.getExe myCustomDwlPackage} -s "${pkgs.dwlb}/bin/dwlb -font \"monospace:size=16\"" "$@"
    '';
in

{
  imports =
    [ # Include the results of the hardware scan.
      ./hardware-configuration.nix
    ];

  # Use the systemd-boot EFI boot loader.
  boot.loader.systemd-boot.enable = true;
  boot.loader.efi.canTouchEfiVariables = true;
  boot.tmp.cleanOnBoot = true;

  # zfs
  systemd.services.zfs-mount.enable = false;
  networking.hostId = "ad26d962";

  # console keymap
  console.keyMap = "us";
  nixpkgs.config.allowUnfree = true;

  # networking
  networking.hostName = "pollux"; # Define your hostname.
  networking.networkmanager.enable = true;  # Easiest to use and most distros use this by default.

  # Set your time zone.
  time.timeZone = "Europe/London";

#  # system auto upgrade
#  system.autoUpgrade = {
#      enable = true;
#      dates = "daily";
#      allowReboot = false;
#  };

  # nix garbage collection
  nix = {
    settings.auto-optimise-store = true;
    gc = {
      automatic = true;
      dates = "weekly";
      options = "--delete-older-than 7d";
    };
  };

  # Select internationalisation properties.
  i18n.defaultLocale = "en_GB.UTF-8";

  i18n.extraLocaleSettings = {
    LC_ADDRESS = "en_GB.UTF-8";
    LC_IDENTIFICATION = "en_GB.UTF-8";
    LC_MEASUREMENT = "en_GB.UTF-8";
    LC_MONETARY = "en_GB.UTF-8";
    LC_NAME = "en_GB.UTF-8";
    LC_NUMERIC = "en_GB.UTF-8";
    LC_PAPER = "en_GB.UTF-8";
    LC_TELEPHONE = "en_GB.UTF-8";
    LC_TIME = "en_GB.UTF-8";
  };

  # nix flakes
  nix.settings.experimental-features = [ "nix-command" "flakes" ];

  # --- XDG Desktop Portal Configuration for Wayland ---
  xdg.portal = {
    enable = true;
    xdgOpenUsePortal = true; # Recommended for better portal integration
    wlr.enable = true;       # This is the crucial part for wlroots compositors
  };

  # Enable the X11 windowing system.
  services = { 
    system76-scheduler.enable = true; # cosmic scheduler
    spice-vdagentd.enable = true;      # Guest agent for SPICE (copy/paste, etc.)
    xserver = { 
    enable = true;

    videoDrivers = [ "nvidia" ];

    # xkb
    xkb = {
      layout = "gb";
      variant = "mac";
      };
    };

    # Enable the COSMIC login manager
    displayManager.cosmic-greeter.enable = true;
  
    # Enable the COSMIC desktop environment
    desktopManager.cosmic.enable = true;

    zfs.autoScrub.enable = true;
    znapzend = {
      enable = true;
      autoCreation = true;
      pure = true;
      zetup = {
          "zpool/home" = {
            recursive = true;
            mbuffer.enable = true;
            plan = "1h=>1h,1d=>1h,1w=>1d,1m=>1w"; # Take snapshots every hour
          };
        };
      };

    fwupd.enable = true;
    thermald.enable = true;
    openssh.enable = true;
    printing.enable = false;
    libinput.enable = true;

    pipewire = {
      enable = true;
      alsa.enable = true;
      alsa.support32Bit = true;
      pulse.enable = true;
      jack.enable = true;
   };
};


  # comsic clipboard
  environment.sessionVariables.COSMIC_DATA_CONTROL_ENABLED = 1;

hardware = {
  nvidia.open = false;
  graphics ={
    enable = true;
    extraPackages = with pkgs; [
      intel-vaapi-driver
      libva-vdpau-driver
      libvdpau-va-gl
    ];
  };
};
  
# Enable common container config files in /etc/containers
hardware.nvidia-container-toolkit.enable = true;

# containers registries
virtualisation = {
  containers = {
  enable = true;
  registries.search = [
  "docker.io"
  "quay.io"
  ];
    storage.settings = {
      storage = {
        driver = "zfs";
        graphroot = "/var/lib/containers/storage";
        runroot = "/run/containers/storage";
      };
    };
  };
  podman = {
    enable = true;

    # Create a `docker` alias for podman, to use it as a drop-in replacement
    dockerCompat = true;

    # Required for containers under podman-compose to be able to talk to each other.
    defaultNetwork.settings.dns_enabled = true;
    };

   # New Libvirtd settings for Windows 11
    libvirtd = {
      enable = true;
      qemu = {
        package = pkgs.qemu_kvm;
        runAsRoot = true;
        swtpm.enable = true; # Required for Windows 11 TPM
      };
    };
    spiceUSBRedirection.enable = true;
};


# podman zfs
fileSystems."/var/lib/containers/storage" = {
  device = "zpool/containers";
  fsType = "zfs";
  options = [ "zfsutil" ];
};


# users
users.mutableUsers = true;

  # Define a user account. Don't forget to set a password with ‘passwd’.
users.users.djwilcox = {
    isNormalUser = true;
    extraGroups = [ "wheel" "networkmanager" "audio" "video" "oci" "libvirtd" ]; # Enable ‘sudo’ for the user.
};

programs = {
  # dwl
  dwl = {
    enable = true;
    # Tell the dwl module to use our wrapper script as the dwl executable
    package = dwlWithDwlbWrapper;
  };

  zsh = {
    enable = true;
    enableCompletion = true;
    syntaxHighlighting.enable = true;
  };
  dconf.enable = true;
  #ssh.startAgent = true;


  mtr.enable = true;
  gnupg.agent = {
    enable = true;
    enableSSHSupport = true;
  };
};

users.users.djwilcox.shell = pkgs.zsh;
#enviroment.pathsToLink = [ "/share/zsh" ];
#enviroment.shells = with pkgs; [ zsh ];

security.sudo.enable = true;

# rtkit for audio
security.rtkit.enable = true;

# pam setting for audio
security.pam.loginLimits = [
  { domain = "@audio"; item = "memlock"; type = "-"; value = "unlimited"; }
  { domain = "@audio"; item = "rtprio"; type = "-"; value = "99"; }
  { domain = "@audio"; item = "nofile"; type = "soft"; value = "99999"; }
  { domain = "@audio"; item = "nofile"; type = "hard"; value = "99999"; }
];


# doas
security.doas = {
  enable = true;
  extraConfig = ''
    # allow user
    permit keepenv setenv { PATH } djwilcox
    
    # allow root to switch to our user
    permit nopass keepenv setenv { PATH } root as djwilcox

    # nopass
    permit nopass keepenv setenv { PATH } djwilcox

    # nixos-rebuild switch
    permit nopass keepenv setenv { PATH } djwilcox cmd nixos-rebuild
    
    # root as root
    permit nopass keepenv setenv { PATH } root as root
  '';
};


  # List packages installed in system profile. To search, run:
  # The programs.dwl module creates its own dwl.desktop,
  # which will now correctly launch our wrapper script.
  environment.systemPackages = with pkgs; lib.filter (p: ! (lib.hasAttr "providedSessions" p && p.providedSessions == [ "dwl" ])) [
  vim # Do not forget to add an editor to edit configuration.nix! The Nano editor is also installed by default.

  #dwl
  dwlb 
  xdg-desktop-portal-wlr
  # podman
  podman-compose
];

  # Some programs need SUID wrappers, can be configured further or are
  # started in user sessions.

  # List services that you want to enable:

  # Enable the OpenSSH daemon.
  # services.openssh.enable = true;

  # Open ports in the firewall.
  # transmission ports 6881 6882
  # searxng port 8080
  # open-webui port 3000
  # invidious port 3000 8282
  # n8n port 5678
  # crawl4ai 11235
  networking.firewall.allowedTCPPorts = [ 6881 8080 3000 8282 5678 11235 ];
  networking.firewall.allowedUDPPorts = [ 6882 ];
  # Or disable the firewall altogether.
  # networking.firewall.enable = false;

  # Copy the NixOS configuration file and link it from the resulting system
  # (/run/current-system/configuration.nix). This is useful in case you
  # accidentally delete configuration.nix.
  #system.copySystemConfiguration = true;

  # This option defines the first version of NixOS you have installed on this particular machine,
  # and is used to maintain compatibility with application data (e.g. databases) created on older NixOS versions.
  #
  # Most users should NEVER change this value after the initial install, for any reason,
  # even if you've upgraded your system to a new NixOS release.
  #
  # This value does NOT affect the Nixpkgs version your packages and OS are pulled from,
  # so changing it will NOT upgrade your system - see https://nixos.org/manual/nixos/stable/#sec-upgrading for how
  # to actually do that.
  #
  # This value being lower than the current NixOS release does NOT mean your system is
  # out of date, out of support, or vulnerable.
  #
  # Do NOT change this value unless you have manually inspected all the changes it would make to your configuration,
  # and migrated your data accordingly.
  #
  # For more information, see `man configuration.nix` or https://nixos.org/manual/nixos/stable/options#opt-system.stateVersion .
  system.stateVersion = "25.05"; # Did you read the comment?

}
#+end_src

** hardware.nix
*** hardware.nix snippet

make sure kvm-intel is set in your hardware.nix

#+begin_src nix

# Do not modify this file!  It was generated by ‘nixos-generate-config’
# and may be overwritten by future invocations.  Please make changes
# to /etc/nixos/configuration.nix instead.
{ config, lib, pkgs, modulesPath, ... }:

{
  boot.kernelModules = [ "kvm-intel" ];
}

#+end_src

*** hardware.nix complete

#+begin_src nix
# Do not modify this file!  It was generated by ‘nixos-generate-config’
# and may be overwritten by future invocations.  Please make changes
# to /etc/nixos/configuration.nix instead.
{ config, lib, pkgs, modulesPath, ... }:

{
  imports =
    [ (modulesPath + "/installer/scan/not-detected.nix")
    ];

  boot.initrd.availableKernelModules = [ "xhci_pci" "ahci" "nvme" "usb_storage" "sd_mod" "rtsx_pci_sdmmc" ];
  boot.initrd.kernelModules = [ ];
  boot.kernelModules = [ "kvm-intel" ];
  boot.extraModulePackages = [ ];

  fileSystems."/" =
    { device = "zpool/root";
      fsType = "zfs";
      options = [ "zfsutil" ];
    };

  fileSystems."/nix" =
    { device = "zpool/nix";
      fsType = "zfs";
      options = [ "zfsutil" ];
    };

  fileSystems."/var" =
    { device = "zpool/var";
      fsType = "zfs";
      options = [ "zfsutil" ];
    };

  fileSystems."/home" =
    { device = "zpool/home";
      fsType = "zfs";
      options = [ "zfsutil" ];
    };

  fileSystems."/boot" =
    { device = "/dev/disk/by-id/nvme-Micron_2300_NVMe_1024GB_________20342A09973B-part1";
      fsType = "vfat";
      options = [ "fmask=0022" "dmask=0022" ];
    };

  swapDevices =
    [ { device = "/dev/disk/by-id/nvme-Micron_2300_NVMe_1024GB_________20342A09973B-part2";
        randomEncryption = true;
    }];

  # Enables DHCP on each ethernet and wireless interface. In case of scripted networking
  # (the default) this is the recommended approach. When using systemd-networkd it's
  # still possible to use this option, but it's recommended to use it in conjunction
  # with explicit per-interface declarations with `networking.interfaces.<interface>.useDHCP`.
  networking.useDHCP = lib.mkDefault true;
  # networking.interfaces.enp0s20f0u2u3.useDHCP = lib.mkDefault true;
  # networking.interfaces.wlp59s0.useDHCP = lib.mkDefault true;

  nixpkgs.hostPlatform = lib.mkDefault "x86_64-linux";
  hardware.cpu.intel.updateMicrocode = lib.mkDefault config.hardware.enableRedistributableFirmware;
}


#+end_src

** packages

packages to install with home-manager

#+begin_src nix
virt-manager
virt-viewer
spice 
spice-gtk 
spice-protocol
virtio-win
win-spice
adwaita-icon-theme
#+end_src

** virt manager

[[https://nixos.wiki/wiki/Virt-manager]]

You will get a warning when you open it for the first time

Could not detect a default hypervisor. Make sure the appropriate virtualization packages containing kvm, qemu, libvirt, etc. are installed and that libvirtd is running.

To resolve

File (in the menu bar) -> Add connection

HyperVisor = QEMU/KVM
Autoconnect = checkmark

Connect

** libvirt pool
*** zfs

Create the dataset with the mountpoint set to your desired home path

#+begin_src sh
doas zfs create -o mountpoint=/home/djwilcox/libvirt zpool/home/libvirt
#+end_src

Set the recordsize to 64k (Optimized for KVM/Windows 11)

#+begin_src sh
doas zfs set recordsize=64k zpool/home/libvirt
#+end_src

Set the compression (lz4 is usually best for performance/space balance)

#+begin_src sh
doas zfs set compression=lz4 zpool/home/libvirt
#+end_src

After ZFS mounts the new dataset, it will be owned by root.

You need to change the ownership so your user and the libvirt service can use it:

#+begin_src sh
doas chown -R "${USER}":libvirtd /home/djwilcox/libvirt
#+end_src

#+begin_src sh
chmod 755 libvirt
#+end_src

*** create a directory for the libvirt storage pool

#+begin_src sh
mkdir -p ~/libvirt/images
#+end_src

not needed if using zfs - chown the libvirt directory to allow both your user and the libvirt group access

#+begin_src sh
doas chown -R "${USER}":libvirt "${HOME}":/libvirt
#+end_src

this step is required even if using zfs

#+begin_src sh
chmod o+x /home/"${USER}"
#+end_src

*** list libvirt pool

#+begin_src sh
doas virsh pool-list --all
#+end_src

*** stop default pool

#+begin_src sh
doas virsh pool-destroy default
#+end_src

*** remove default pool

#+begin_src sh
doas virsh pool-undefine default
#+end_src

*** create new pool

#+begin_src sh
doas virsh pool-define-as --name default --type dir --target /home/"${USER}"/libvirt/images 
#+end_src

*** start the new pool

#+begin_src sh
doas virsh pool-start default
#+end_src

*** autostart the new pool

#+begin_src sh
doas virsh pool-autostart default
#+end_src

*** list pools

#+begin_src sh
doas virsh pool-list --all
#+end_src

** windows
*** change into the images directory

#+begin_src sh
cd ~/libvirt/images
#+end_src

download virtio-win.iso

#+begin_src sh
curl -L -O https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/latest-virtio/virtio-win.iso
#+end_src

*** 1. Confirm Hardware Requirements

Firmware & Chipset: Your screen shows UEFI and Q35 are already selected, which is correct for Windows 11.

TPM: Look at the bottom of the left sidebar. It currently says TPM vNone. You must click Add Hardware, select TPM, and ensure it is set to Model: TIS and Version: 2.0. Windows 11 will not install without this.

Memory: Since you intend to record with OBS Studio while leaving room for the host, verify under the Memory tab that it is set to 8192 MiB.

CPUs: In the CPUs section, set the count to 4 and ensure "Copy host CPU configuration" is checked so the VM can use your Intel i7's native features.

*** 2. Optimize for ZFS and Performance

Storage (SATA Disk 1): Click on SATA Disk 1. Change the Disk bus to VirtIO. Under Performance options, set Cache mode to none and IO mode to native to properly utilize your ZFS pool.

Network (NIC): Click on your NIC and change the Device model to virtio for better throughput.

*** 3. Add virtio-win.iso to your VM

Now back in your virt-manager customization window:

Click Add Hardware (bottom left) -> Storage.

Set Device type to CDROM device.

Click Manage... and browse to ~/libvirt/images/virtio-win.iso.

*** 4. Proceed to "Begin Installation"

With both ISOs (Windows 11 and VirtIO) attached as CD-ROMs:

Click Begin Installation.

Mash your keys to boot from the CD.

When you get to the "Where do you want to install Windows?" screen and it's empty:

Click Load Driver -> Browse.

Find the VirtIO-Win CD.

Look for vioscsi or viostor -> w11 -> amd64.

For the Disk: Go to amd64/w11 (or vioscsi/w11/amd64) to make your ZFS drive appear.

Once that loads, your ZFS disk will appear!

For the Network: After the install finishes (or during the "connect to network" step), you can load the driver from NetKVM/w11/amd64.

*** 5 Product Key Screen:

When it asks for a key, click "I don't have a product key" at the bottom.

*** 6 select image

select Windows 11 pro

*** 7 select location to install windows 11

You are at the critical stage where the VirtIO drivers are needed to see your ZFS-backed storage. Since the window is currently empty, Windows doesn't yet have the "map" to find your virtual disk.

Load the Storage Driver

Follow these steps to make your drive appear:

Click Load Driver (the icon with the small CD and green arrow).

Click Browse in the popup window.

Locate and expand the CD Drive labeled virtio-win (usually Drive E:).

Navigate to the following folder path: vioscsi -> w11 -> amd64.

Click OK. You should see "Red Hat VirtIO SCSI pass-through controller" listed.

Troubleshooting the Empty List

If the list remains empty after clicking OK, try these two quick fixes:

working fix

Try the alternate folder: If vioscsi doesn't show a driver, click Browse and navigate to E:\viostor\w11\amd64 instead. Both are storage drivers, but depending on your exact QEMU version, one may be preferred over the other.

select Red Hat Virtio SCSI controller and click install

*** 8 select location to install windows 11

select the drive

*** 9 installing windows

Handling the First Reboot

Once those stages reach 100%, the VM will automatically restart.

Important: You might see a black screen that says "Press any key to boot from CD or DVD" again. Do not press anything. * You want it to boot from your virtual hard drive to continue the "Out of Box Experience" (setting up your region, keyboard, and user account).

*** The "Pro-Tip" for Windows 11 Home/Pro Setup

Windows 11 often forces you to connect to the internet during setup. Since you are using a VirtIO Network driver, the installer won't have internet until you load the driver.

If you get stuck on a "Let's connect you to a network" screen with no "Next" button:

Press Shift + F10 on your keyboard to open a Command Prompt.

note: press the ~ keyboard for \

Type OOBE\BYPASSNRO and press Enter.

The VM will reboot, and you will now have an option that says "I don't have internet" so you can finish the account setup.

*** 10 create user account

enter user name and answer security questions

*** 11 set up the network

How to install the Guest Tools:

Open File Explorer: Click the folder icon on your taskbar.

Go to "This PC": On the left sidebar, click This PC.

Open the VirtIO Drive: You should see a CD drive labeled virtio-win. Double-click it to open it.

Run the Installer:

Look for a file named virtio-win-gt-x64 (it has a small computer icon).

Double-click it to start the setup.

Follow the Wizard:

Click Next, I accept, and keep all the default features selected.

During the process, Windows will pop up several "Security" boxes asking if you want to install drivers from "Red Hat, Inc."

Always click Install for every popup.

*** 12 display

right click on the start button and select device manager

Instead of letting Windows search the folder, you need to "force-feed" it:

Open Device Manager -> Display Adapters.

Right-click Microsoft Basic Display Adapter -> Update driver.

Click "Browse my computer for drivers."

CRITICAL STEP: Click "Let me pick from a list of available drivers on my computer."

Click the Have Disk... button in the bottom right.

Click Browse and go to your E:\ drive (the VirtIO CD).

Navigate to qxldod -> w11 -> amd64.

If w11 isn't there, use w10 -> amd64.

Select the file ending in .inf (usually qxldod.inf) and click Open, then OK.

Select the Red Hat VirtIO GPU DOD controller from the list and click Next.

Click Yes if a warning pops up about compatibility.

Go back to Settings > System > Display.

Look at the Scale setting (just above resolution).

I recommend setting it to 125% or 150%. This keeps your recording area at 1080p but makes the Windows interface much easier to navigate.

*** virsh dumpxml

#+begin_src sh
doas virsh dumpxml win11 > win11_backup.xml
#+end_src

**** win11 xml

#+begin_src xml
<domain type='kvm'>
  <name>win11</name>
  <uuid>803230f8-74ec-4964-bf55-56fcc64df61b</uuid>
  <metadata>
    <libosinfo:libosinfo xmlns:libosinfo="http://libosinfo.org/xmlns/libvirt/domain/1.0">
      <libosinfo:os id="http://microsoft.com/win/11"/>
    </libosinfo:libosinfo>
  </metadata>
  <memory unit='KiB'>8388608</memory>
  <currentMemory unit='KiB'>8388608</currentMemory>
  <vcpu placement='static'>4</vcpu>
  <os firmware='efi'>
    <type arch='x86_64' machine='pc-q35-10.1'>hvm</type>
    <firmware>
      <feature enabled='no' name='enrolled-keys'/>
      <feature enabled='yes' name='secure-boot'/>
    </firmware>
    <loader readonly='yes' secure='yes' type='pflash' format='raw'>/run/libvirt/nix-ovmf/edk2-x86_64-secure-code.fd</loader>
    <nvram template='/run/libvirt/nix-ovmf/edk2-i386-vars.fd' templateFormat='raw' format='raw'>/var/lib/libvirt/qemu/nvram/win11_VARS.fd</nvram>
    <boot dev='hd'/>
  </os>
  <features>
    <acpi/>
    <apic/>
    <hyperv mode='custom'>
      <relaxed state='on'/>
      <vapic state='on'/>
      <spinlocks state='on' retries='8191'/>
      <vpindex state='on'/>
      <runtime state='on'/>
      <synic state='on'/>
      <stimer state='on'/>
      <frequencies state='on'/>
      <tlbflush state='on'/>
      <ipi state='on'/>
      <evmcs state='on'/>
      <avic state='on'/>
    </hyperv>
    <vmport state='off'/>
    <smm state='on'/>
  </features>
  <cpu mode='host-passthrough' check='none' migratable='on'/>
  <clock offset='localtime'>
    <timer name='rtc' tickpolicy='catchup'/>
    <timer name='pit' tickpolicy='delay'/>
    <timer name='hpet' present='no'/>
    <timer name='hypervclock' present='yes'/>
  </clock>
  <on_poweroff>destroy</on_poweroff>
  <on_reboot>restart</on_reboot>
  <on_crash>destroy</on_crash>
  <pm>
    <suspend-to-mem enabled='no'/>
    <suspend-to-disk enabled='no'/>
  </pm>
  <devices>
    <emulator>/run/libvirt/nix-emulators/qemu-system-x86_64</emulator>
    <disk type='file' device='disk'>
      <driver name='qemu' type='qcow2' cache='none' discard='unmap'/>
      <source file='/home/djwilcox/libvirt/images/win11.qcow2'/>
      <target dev='vda' bus='virtio'/>
      <address type='pci' domain='0x0000' bus='0x04' slot='0x00' function='0x0'/>
    </disk>
    <disk type='file' device='cdrom'>
      <driver name='qemu' type='raw'/>
      <source file='/home/djwilcox/libvirt/images/win11.iso'/>
      <target dev='sdb' bus='sata'/>
      <readonly/>
      <address type='drive' controller='0' bus='0' target='0' unit='1'/>
    </disk>
    <disk type='file' device='cdrom'>
      <driver name='qemu' type='raw'/>
      <source file='/home/djwilcox/libvirt/images/virtio-win.iso'/>
      <target dev='sdc' bus='sata'/>
      <readonly/>
      <address type='drive' controller='0' bus='0' target='0' unit='2'/>
    </disk>
    <controller type='usb' index='0' model='qemu-xhci' ports='15'>
      <address type='pci' domain='0x0000' bus='0x02' slot='0x00' function='0x0'/>
    </controller>
    <controller type='pci' index='0' model='pcie-root'/>
    <controller type='pci' index='1' model='pcie-root-port'>
      <model name='pcie-root-port'/>
      <target chassis='1' port='0x10'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x0' multifunction='on'/>
    </controller>
    <controller type='pci' index='2' model='pcie-root-port'>
      <model name='pcie-root-port'/>
      <target chassis='2' port='0x11'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x1'/>
    </controller>
    <controller type='pci' index='3' model='pcie-root-port'>
      <model name='pcie-root-port'/>
      <target chassis='3' port='0x12'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x2'/>
    </controller>
    <controller type='pci' index='4' model='pcie-root-port'>
      <model name='pcie-root-port'/>
      <target chassis='4' port='0x13'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x3'/>
    </controller>
    <controller type='pci' index='5' model='pcie-root-port'>
      <model name='pcie-root-port'/>
      <target chassis='5' port='0x14'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x4'/>
    </controller>
    <controller type='pci' index='6' model='pcie-root-port'>
      <model name='pcie-root-port'/>
      <target chassis='6' port='0x15'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x5'/>
    </controller>
    <controller type='pci' index='7' model='pcie-root-port'>
      <model name='pcie-root-port'/>
      <target chassis='7' port='0x16'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x6'/>
    </controller>
    <controller type='pci' index='8' model='pcie-root-port'>
      <model name='pcie-root-port'/>
      <target chassis='8' port='0x17'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x7'/>
    </controller>
    <controller type='pci' index='9' model='pcie-root-port'>
      <model name='pcie-root-port'/>
      <target chassis='9' port='0x18'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x0' multifunction='on'/>
    </controller>
    <controller type='pci' index='10' model='pcie-root-port'>
      <model name='pcie-root-port'/>
      <target chassis='10' port='0x19'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x1'/>
    </controller>
    <controller type='pci' index='11' model='pcie-root-port'>
      <model name='pcie-root-port'/>
      <target chassis='11' port='0x1a'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x2'/>
    </controller>
    <controller type='pci' index='12' model='pcie-root-port'>
      <model name='pcie-root-port'/>
      <target chassis='12' port='0x1b'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x3'/>
    </controller>
    <controller type='pci' index='13' model='pcie-root-port'>
      <model name='pcie-root-port'/>
      <target chassis='13' port='0x1c'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x4'/>
    </controller>
    <controller type='pci' index='14' model='pcie-root-port'>
      <model name='pcie-root-port'/>
      <target chassis='14' port='0x1d'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x5'/>
    </controller>
    <controller type='sata' index='0'>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x1f' function='0x2'/>
    </controller>
    <controller type='virtio-serial' index='0'>
      <address type='pci' domain='0x0000' bus='0x03' slot='0x00' function='0x0'/>
    </controller>
    <interface type='network'>
      <mac address='52:54:00:13:46:09'/>
      <source network='default'/>
      <model type='virtio'/>
      <address type='pci' domain='0x0000' bus='0x01' slot='0x00' function='0x0'/>
    </interface>
    <serial type='pty'>
      <target type='isa-serial' port='0'>
        <model name='isa-serial'/>
      </target>
    </serial>
    <console type='pty'>
      <target type='serial' port='0'/>
    </console>
    <channel type='spicevmc'>
      <target type='virtio' name='com.redhat.spice.0'/>
      <address type='virtio-serial' controller='0' bus='0' port='1'/>
    </channel>
    <input type='tablet' bus='usb'>
      <address type='usb' bus='0' port='1'/>
    </input>
    <input type='mouse' bus='ps2'/>
    <input type='keyboard' bus='ps2'/>
    <tpm model='tpm-tis'>
      <backend type='emulator' version='2.0'/>
    </tpm>
    <graphics type='spice' autoport='yes'>
      <listen type='address'/>
      <image compression='off'/>
    </graphics>
    <sound model='ich9'>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x1b' function='0x0'/>
    </sound>
    <audio id='1' type='spice'/>
    <video>
      <model type='qxl' ram='65536' vram='65536' vgamem='16384' heads='1' primary='yes'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x0'/>
    </video>
    <redirdev bus='usb' type='spicevmc'>
      <address type='usb' bus='0' port='2'/>
    </redirdev>
    <redirdev bus='usb' type='spicevmc'>
      <address type='usb' bus='0' port='3'/>
    </redirdev>
    <watchdog model='itco' action='reset'/>
    <memballoon model='virtio'>
      <address type='pci' domain='0x0000' bus='0x05' slot='0x00' function='0x0'/>
    </memballoon>
  </devices>
</domain>


#+end_src

*** window notes

[[https://www.youtube.com/watch?v=rCVW8BGnYIc]]

[[https://raw.githubusercontent.com/TechsupportOnHold/Nixos-VM/main/vm.nix]]

** osx-kvm

[[https://github.com/kholia/OSX-KVM]]

*** clone the repo

#+begin_src sh
git clone --depth 1 --recursive https://github.com/kholia/OSX-KVM.git
#+end_src
*** fetch the mac installer

#+begin_src sh
./fetch-macOS-v2.py
#+end_src

You can choose your desired macOS version here.
After executing this step, you should have the BaseSystem.dmg file in the current folder.

ATTENTION: Let >= Big Sur setup sit at the Country Selection screen, and other similar places for a while if things are being slow. The initial macOS setup wizard will eventually succeed.

Sample run:

#+begin_example
$ ./fetch-macOS-v2.py
1. High Sierra (10.13)
2. Mojave (10.14)
3. Catalina (10.15)
4. Big Sur (11.7) - RECOMMENDED
5. Monterey (12.6)
6. Ventura (13)

Choose a product to download (1-6): 4
#+end_example

*** dmg2img

#+begin_src sh
dmg2img -i BaseSystem.dmg BaseSystem.img
#+end_src

*** qemu create hd

create mac_hdd_ng.img with qemu

#+begin_src sh
qemu-img create -f qcow2 mac_hdd_ng.img 128G
#+end_src

*** move the osx-kvm directory to the libvirt images directory

#+begin_src sh
doas mv OSX-KVM /var/lib/libvirt/images
#+end_src

*** change the permissions on the OSX-KVM directory

#+begin_src sh
doas chown -R root:libvirtd /var/lib/libvirt/images/OSX-KVM
#+end_src

*** macosx.xml

mac osx xml

#+begin_src xml
<domain xmlns:qemu="http://libvirt.org/schemas/domain/qemu/1.0" type="kvm">
  <name>macOS</name>
  <uuid>2aca0dd6-cec9-4717-9ab2-0b7b13d111c3</uuid>
  <title>macOS</title>
  <memory unit="KiB">8392704</memory>
  <currentMemory unit="KiB">8392704</currentMemory>
  <vcpu placement="static">4</vcpu>
  <os>
    <type arch="x86_64" machine="pc-q35-4.2">hvm</type>
    <loader readonly="yes" type="pflash">/var/lib/libvirt/images/OSX-KVM/OVMF_CODE.fd</loader>
    <nvram>/var/lib/libvirt/images/OSX-KVM/OVMF_VARS-1920x1080.fd</nvram>
  </os>
  <features>
    <acpi/>
    <apic/>
  </features>
  <cpu mode="custom" match="exact" check="none">
    <model fallback="forbid">qemu64</model>
  </cpu>
  <clock offset="utc">
    <timer name="rtc" tickpolicy="catchup"/>
    <timer name="pit" tickpolicy="delay"/>
    <timer name="hpet" present="no"/>
  </clock>
  <on_poweroff>destroy</on_poweroff>
  <on_reboot>restart</on_reboot>
  <on_crash>restart</on_crash>
  <devices>
    <emulator>/run/current-system/sw/bin/qemu-system-x86_64</emulator>
    <disk type="file" device="disk">
      <driver name="qemu" type="qcow2" cache="writeback" io="threads"/>
      <source file="/var/lib/libvirt/images/OSX-KVM/OpenCore/OpenCore.qcow2"/>
      <target dev="sda" bus="sata"/>
      <boot order="2"/>
      <address type="drive" controller="0" bus="0" target="0" unit="0"/>
    </disk>
    <disk type="file" device="disk">
      <driver name="qemu" type="qcow2" cache="writeback" io="threads"/>
      <source file="/var/lib/libvirt/images/OSX-KVM/mac_hdd_ng.img"/>
      <target dev="sdb" bus="sata"/>
      <boot order="1"/>
      <address type="drive" controller="0" bus="0" target="0" unit="1"/>
    </disk>
    <disk type="file" device="disk">
      <driver name="qemu" type="raw" cache="writeback"/>
      <source file="/var/lib/libvirt/images/OSX-KVM/BaseSystem.img"/>
      <target dev="sdc" bus="sata"/>
      <boot order="3"/>
      <address type="drive" controller="0" bus="0" target="0" unit="2"/>
    </disk>
    <controller type="sata" index="0">
      <address type="pci" domain="0x0000" bus="0x00" slot="0x1f" function="0x2"/>
    </controller>
    <controller type="pci" index="0" model="pcie-root"/>
    <controller type="pci" index="1" model="pcie-root-port">
      <model name="pcie-root-port"/>
      <target chassis="1" port="0x8"/>
      <address type="pci" domain="0x0000" bus="0x00" slot="0x01" function="0x0" multifunction="on"/>
    </controller>
    <controller type="pci" index="2" model="pcie-root-port">
      <model name="pcie-root-port"/>
      <target chassis="2" port="0x9"/>
      <address type="pci" domain="0x0000" bus="0x00" slot="0x01" function="0x1"/>
    </controller>
    <controller type="pci" index="3" model="pcie-root-port">
      <model name="pcie-root-port"/>
      <target chassis="3" port="0xa"/>
      <address type="pci" domain="0x0000" bus="0x00" slot="0x01" function="0x2"/>
    </controller>
    <controller type="pci" index="4" model="pcie-root-port">
      <model name="pcie-root-port"/>
      <target chassis="4" port="0xb"/>
      <address type="pci" domain="0x0000" bus="0x00" slot="0x01" function="0x3"/>
    </controller>
    <controller type="pci" index="5" model="pcie-root-port">
      <model name="pcie-root-port"/>
      <target chassis="5" port="0xc"/>
      <address type="pci" domain="0x0000" bus="0x00" slot="0x01" function="0x4"/>
    </controller>
    <controller type="pci" index="6" model="pcie-root-port">
      <model name="pcie-root-port"/>
      <target chassis="6" port="0xd"/>
      <address type="pci" domain="0x0000" bus="0x00" slot="0x01" function="0x5"/>
    </controller>
    <controller type="pci" index="7" model="pcie-root-port">
      <model name="pcie-root-port"/>
      <target chassis="7" port="0xe"/>
      <address type="pci" domain="0x0000" bus="0x00" slot="0x01" function="0x6"/>
    </controller>
    <controller type="pci" index="8" model="pcie-root-port">
      <model name="pcie-root-port"/>
      <target chassis="8" port="0xf"/>
      <address type="pci" domain="0x0000" bus="0x00" slot="0x01" function="0x7"/>
    </controller>
    <controller type="pci" index="9" model="pcie-to-pci-bridge">
      <model name="pcie-pci-bridge"/>
      <address type="pci" domain="0x0000" bus="0x01" slot="0x00" function="0x0"/>
    </controller>
    <controller type="virtio-serial" index="0">
      <address type="pci" domain="0x0000" bus="0x02" slot="0x00" function="0x0"/>
    </controller>
    <controller type="usb" index="0" model="ich9-ehci1">
      <address type="pci" domain="0x0000" bus="0x00" slot="0x07" function="0x7"/>
    </controller>
    <controller type="usb" index="0" model="ich9-uhci1">
      <master startport="0"/>
      <address type="pci" domain="0x0000" bus="0x00" slot="0x07" function="0x0" multifunction="on"/>
    </controller>
    <controller type="usb" index="0" model="ich9-uhci2">
      <master startport="2"/>
      <address type="pci" domain="0x0000" bus="0x00" slot="0x07" function="0x1"/>
    </controller>
    <controller type="usb" index="0" model="ich9-uhci3">
      <master startport="4"/>
      <address type="pci" domain="0x0000" bus="0x00" slot="0x07" function="0x2"/>
    </controller>
    <interface type="bridge">
      <mac address="52:54:00:e6:85:40"/>
      <source bridge="virbr0"/>
      <model type="vmxnet3"/>
      <address type="pci" domain="0x0000" bus="0x09" slot="0x02" function="0x0"/>
    </interface>
    <serial type="pty">
      <target type="isa-serial" port="0">
        <model name="isa-serial"/>
      </target>
    </serial>
    <console type="pty">
      <target type="serial" port="0"/>
    </console>
    <channel type="unix">
      <target type="virtio" name="org.qemu.guest_agent.0"/>
      <address type="virtio-serial" controller="0" bus="0" port="1"/>
    </channel>
    <input type="mouse" bus="ps2"/>
    <input type="keyboard" bus="ps2"/>
    <graphics type="spice" autoport="yes">
      <listen type="address"/>
    </graphics>
    <audio id="1" type="spice"/>
    <video>
      <model type="virtio" heads="1" primary="yes">
        <acceleration accel3d="no"/>
      </model>
      <address type="pci" domain="0x0000" bus="0x03" slot="0x00" function="0x0"/>
    </video>
    <memballoon model="none"/>
  </devices>
  <qemu:commandline>
    <qemu:arg value="-device"/>
    <qemu:arg value="isa-applesmc,osk=ourhardworkbythesewordsguardedpleasedontsteal(c)AppleComputerInc"/>
    <qemu:arg value="-smbios"/>
    <qemu:arg value="type=2"/>
    <qemu:arg value="-usb"/>
    <qemu:arg value="-device"/>
    <qemu:arg value="usb-tablet"/>
    <qemu:arg value="-device"/>
    <qemu:arg value="usb-kbd"/>
    <qemu:arg value="-cpu"/>
    <qemu:arg value="Penryn,kvm=on,vendor=GenuineIntel,+invtsc,vmware-cpuid-freq=on,+ssse3,+sse4.2,+popcnt,+avx,+aes,+xsave,+xsaveopt,check"/>
  </qemu:commandline>
</domain>
#+end_src

create the virtual machine

#+begin_src sh
virsh --connect qemu:///system define macOS.xml
#+end_src

