#+STARTUP: content
* ffmpeg create clips from a vtt subtitles file

create clips for every sentence in a vtt subtitles file that ends with a period

** whipserx

create the vtt subtitles file with whisperx

#+begin_src sh
whisperx input.mp4 --device cuda --model small --language en --output_format vtt
#+end_src

** python
*** subtitle-sentence.py

#+begin_src sh
python3 subtitle-sentence.py -i input.vtt
#+end_src

#+begin_src python
import re
import csv
import sys
import argparse
from typing import List, Tuple

def process_vtt_to_csv(vtt_file_path: str, output_csv_path: str):
    """
    Processes a VTT file, extracts sentences ending in a period, and
    writes their start and end timestamps to a CSV file.

    This script correctly handles sentences that span multiple subtitle blocks
    by building up text until a period is found.

    Args:
        vtt_file_path (str): The path to the input VTT file.
        output_csv_path (str): The path for the output CSV file.
    """
    try:
        with open(vtt_file_path, 'r', encoding='utf-8') as vtt_file, \
             open(output_csv_path, 'w', newline='', encoding='utf-8') as csv_file:
            
            csv_writer = csv.writer(csv_file)
            vtt_content = vtt_file.read()

            # Remove the WEBVTT header and any leading/trailing whitespace
            # before splitting into blocks.
            vtt_content = re.sub(r'WEBVTT\n', '', vtt_content).strip()

            # Split the content into blocks separated by one or more blank lines.
            vtt_blocks = re.split(r'\n\s*\n', vtt_content)

            # State variables for a sentence that might span multiple blocks
            sentence_start_time = None
            current_sentence_text = ""

            # Iterate through each block of text.
            for block in vtt_blocks:
                # Skip empty blocks that might result from the split.
                if not block.strip():
                    continue

                lines = block.split('\n')
                
                # The first line should contain the timestamp.
                if '-->' in lines[0]:
                    timestamps = lines[0].split('-->')
                    block_start_time = timestamps[0].strip()
                    block_end_time = timestamps[1].strip()
                    block_text = " ".join(lines[1:]).strip()

                    # If this is the start of a new sentence, set the start time.
                    if sentence_start_time is None:
                        sentence_start_time = block_start_time

                    # Combine the text from consecutive blocks into a single sentence.
                    current_sentence_text += " " + block_text
                    
                    # Use a regex to find sentences ending with a period.
                    # This ensures we handle periods mid-block correctly and not just at the very end.
                    # Also, it accounts for periods that might be followed by whitespace.
                    sentence_matches = list(re.finditer(r'([^\.]+\.(?!\.))\s*', current_sentence_text))

                    if sentence_matches:
                        for match in sentence_matches:
                            # We only need to write a row for each complete sentence found.
                            # The start time is the initial timestamp of the sentence.
                            # The end time is the end timestamp of the *current* block.
                            csv_writer.writerow([sentence_start_time, block_end_time])

                            # Reset the state for the next sentence, but carry over any
                            # remaining text in the current block.
                            current_sentence_text = current_sentence_text[match.end():].strip()
                            if not current_sentence_text:
                                sentence_start_time = None
                            else:
                                # If there's more text, the new sentence starts from the end of the previous one,
                                # which means we need to find the start time of this next part.
                                # Since we're parsing block by block, we'll just let the next iteration
                                # pick up the new start time.
                                sentence_start_time = None

                    # If no sentence was completed in this block, just continue to the next one.
                    # The `current_sentence_text` and `sentence_start_time` will persist.

    except FileNotFoundError:
        print(f"Error: The file '{vtt_file_path}' was not found.", file=sys.stderr)
        sys.exit(1)

    print(f"Processing complete. Results written to {output_csv_path}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Extracts start and end timestamps for sentences ending in a period from a VTT file.")
    parser.add_argument("-i", "--input", required=True, help="Path to the input VTT file.")
    parser.add_argument("-o", "--output", default="cutlist.csv", help="Path for the output CSV file. Defaults to 'cutlist.csv'.")
    
    args = parser.parse_args()

    process_vtt_to_csv(args.input, args.output)


#+end_src

*** subtitle-seach.py

replace word or phrase with a word or phrase to search for

#+begin_src sh
python3 subtitle-search.py -i input.vtt -p "word or phrase"
#+end_src

#+begin_src python
import re
import sys
import argparse

def format_timestamp_for_ffmpeg(vtt_timestamp):
    """
    Formats a VTT timestamp (e.g., "01:22.614" or "22.123") into
    the full HH:MM:SS.mmm format required by ffmpeg.
    
    Args:
        vtt_timestamp (str): The timestamp string from the VTT file.
        
    Returns:
        str: The formatted timestamp in "HH:MM:SS.mmm" format.
    """
    # Use a regular expression to handle both MM:SS.mmm and HH:MM:SS.mmm formats.
    match = re.match(r'(?:(\d{1,2}):)?(\d{1,2}):(\d{1,2}\.\d{3})', vtt_timestamp)
    
    if not match:
        # Handle cases like "21.277" which is S.mmm. VTT standard supports this.
        # This will be formatted as 00:00:21.277
        match_seconds = re.match(r'(\d{1,2}\.\d{3})', vtt_timestamp)
        if match_seconds:
            seconds_part = match_seconds.group(1)
            return f"00:00:{seconds_part}"
        else:
            return vtt_timestamp  # Return as-is if format is unexpected
    
    # Extract parts of the timestamp.
    hours, minutes, seconds_milliseconds = match.groups()

    # If hours is None, it means the timestamp was in MM:SS.mmm format.
    if hours is None:
        hours = "00"
    
    # Pad all parts with leading zeros to ensure two digits.
    hours = hours.zfill(2)
    minutes = minutes.zfill(2)
    
    return f"{hours}:{minutes}:{seconds_milliseconds}"


def find_sentences_with_phrases(vtt_file_path, search_phrases, output_csv_path):
    """
    Reads a VTT file, finds sentences containing any of the specified phrases, and
    writes their start and end timestamps to a CSV file with explicit line endings.
    """
    print(f"Searching for phrases in {vtt_file_path}...")
    print(f"Phrases to search for: {', '.join(search_phrases)}")

    # Create a single regex pattern to search for all phrases with a case-insensitive flag.
    # The '|' acts as an OR operator for all the phrases.
    search_pattern = re.compile('|'.join(re.escape(phrase) for phrase in search_phrases), re.IGNORECASE)

    try:
        with open(vtt_file_path, 'r', encoding='utf-8') as vttfile:
            # We read the content and explicitly replace any Windows-style line endings
            # with standard Unix-style ones to ensure consistent processing.
            content = vttfile.read().replace('\r\n', '\n').strip()
        
        # The VTT format uses blank lines to separate blocks.
        blocks = content.strip().split('\n\n')
        
        with open(output_csv_path, 'w', encoding='utf-8') as csvfile:
            # State variables to track a sentence across multiple blocks.
            sentence_start_time = None
            current_sentence_text = ""
            
            # Skip the first line which is "WEBVTT".
            for block in blocks:
                if block.startswith("WEBVTT"):
                    continue

                lines = block.strip().split('\n')
                if len(lines) >= 2 and '-->' in lines[0]:
                    # This is a subtitle block.
                    timestamp_line = lines[0].strip()
                    text_lines = ' '.join(lines[1:]).strip()
                    
                    # Extract timestamps from the line.
                    start_ts_raw, end_ts_raw = timestamp_line.split(' --> ')
                    
                    # Find a period, exclamation mark, or question mark at the end of a sentence.
                    # We are careful to handle cases where a sentence is split across VTT blocks.
                    sentence_end_match = re.search(r'[.!?]\s*$', text_lines)
                    
                    # If this is a new sentence, store its start time.
                    if not current_sentence_text:
                        sentence_start_time = start_ts_raw
                        
                    # Accumulate text for the current sentence.
                    current_sentence_text += " " + text_lines

                    # If we found an ending punctuation mark.
                    if sentence_end_match:
                        # Check if the complete sentence contains the search phrase.
                        if search_pattern.search(current_sentence_text):
                            # Clean the timestamps by stripping any trailing whitespace.
                            cleaned_start = sentence_start_time.strip()
                            cleaned_end = end_ts_raw.strip()

                            # Format timestamps for ffmpeg before writing to CSV.
                            start_ts_formatted = format_timestamp_for_ffmpeg(cleaned_start)
                            end_ts_formatted = format_timestamp_for_ffmpeg(cleaned_end)
                            
                            # Write the row directly to the file with a specific newline.
                            csvfile.write(f"{start_ts_formatted},{end_ts_formatted}\n")
                            print(f"Found match: {start_ts_formatted},{end_ts_formatted} - '{current_sentence_text.strip()}'")

                        # Reset the state for the next sentence.
                        current_sentence_text = ""
                        sentence_start_time = None
    except FileNotFoundError:
        print(f"Error: The file '{vtt_file_path}' was not found.", file=sys.stderr)
        sys.exit(1)

    print(f"Processing complete. Results written to {output_csv_path}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Finds sentences in a VTT file containing specific words or phrases and extracts their timestamps.")
    parser.add_argument("-i", "--input", required=True, help="Path to the input VTT file.")
    parser.add_argument("-p", "--phrase", action="append", required=True, help="Word or phrase to search for. Can be used multiple times.")
    parser.add_argument("-o", "--output", default="cutlist_by_phrase.csv", help="Path for the output CSV file. Defaults to cutlist_by_phrase.csv.")
    
    args = parser.parse_args()

    find_sentences_with_phrases(args.input, args.phrase, args.output)

#+end_src

** ffmpeg use the csv file to create clips

*** scene-cut-to script

#+begin_src sh
#!/bin/sh

#===============================================================================
# scene-cut-to
# ffmpeg scene cut to position
#===============================================================================

# dependencies:
# ffmpeg 

#===============================================================================
# script usage
#===============================================================================

usage () {
# if argument passed to function echo it
[ -z "${1}" ] || echo "! ${1}"
# display help
echo "\
$(basename "$0") -i input -c cutfile

-i input.(mp4|mov|mkv|m4v)
-c cutfile"
exit 2
}


#===============================================================================
# error messages
#===============================================================================

INVALID_OPT_ERR='Invalid option:'
REQ_ARG_ERR='requires an argument'
WRONG_ARGS_ERR='wrong number of arguments passed to script'

#===============================================================================
# check the number of arguments passed to the script
#===============================================================================

[ $# -gt 0 ] || usage "${WRONG_ARGS_ERR}"


#===============================================================================
# getopts check the options passed to the script
#===============================================================================

while getopts ':i:c:h' opt
do
  case ${opt} in
     i) input="${OPTARG}";;
     c) cutfile="${OPTARG}";;
     h) usage;;
     \?) usage "${INVALID_OPT_ERR} ${OPTARG}" 1>&2;;
     :) usage "${INVALID_OPT_ERR} ${OPTARG} ${REQ_ARG_ERR}" 1>&2;;
  esac
done
shift $((OPTIND-1))


#===============================================================================
# variables
#===============================================================================

# get the input file name
input_nopath="${input##*/}"
input_name="${input_nopath%.*}"

#===============================================================================
# ffmpeg create clips - nostdin needed to avoid clash with read command
#===============================================================================

trim_video () {
    output="${input_name}-[${start}-${end}].mp4" 
    ffmpeg \
    -nostdin \
    -hide_banner \
    -stats -v panic \
    -ss "${start}" \
    -to "${end}" \
    -i "${input}" \
    -c:a aac \
    -c:v libx264 -profile:v high \
    -pix_fmt yuv420p -movflags +faststart \
    -f mp4 \
    "${output}"
}


#===============================================================================
# read file and set IFS=, read = input before , end = input after ,
#===============================================================================

count=1
while IFS=, read -r start end; do
  trim_video
done < "${cutfile}"
#+end_src

*** scene-cut-to usage

replace input with the video file to process and cutfile with the csv file

#+begin_src sh
scene-cut-to -i input -c cutfile
#+end_src
